<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Race Car Simulator with User-Controlled Sensor Logic and Syntax Highlighting</title>
  <!-- CodeMirror CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.css">
  <!-- Optionally, include a theme (optional) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/theme/idea.min.css">
  <style>
    body {
      display: flex;
      height: 100vh;
      margin: 0;
      font-family: sans-serif;
    }
    #editor {
      width: 30%;
      padding: 10px;
      background: #f7f7f7;
      border-right: 1px solid #ccc;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
    }
    #editor h3, #editor p, #editor pre {
      margin: 0 0 5px 0;
    }
    #code-editor {
      flex: 1;
    }
    #canvas-container {
      flex: 1;
      position: relative;
      background: #ddd;
    }
    /* Make the CodeMirror editor fill the space */
    .CodeMirror {
      height: 70%;
    }
    button {
      font-size: 16px;
      padding: 5px 10px;
      margin-top: 10px;
    }
    canvas {
      border: 1px solid #000;
      display: block;
      margin: auto;
      background: white;
    }
  </style>
</head>
<body>
  <!-- Left: Code Editor -->
  <div id="editor">
    <h3>Python Code</h3>
    <p>Enter your control code. For example, a bangâ€“bang controller:</p>
    <pre>
def racer_control():
    if racer.sensor_val > 150:
        racer.left_motor_speed = 1
        racer.right_motor_speed = 3
    else:
        racer.left_motor_speed = 3
        racer.right_motor_speed = 1
    </pre>
    <!-- The textarea will be replaced by CodeMirror -->
    <textarea id="code-input" placeholder="Enter your control code here"></textarea>
    <button id="run-code">Run Code</button>
  </div>

  <!-- Right: Simulation Canvas -->
  <div id="canvas-container">
    <canvas id="simCanvas" width="800" height="600"></canvas>
  </div>

  <!-- Load CodeMirror Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/mode/python/python.min.js"></script>

  <!-- Load Pyodide -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js"></script>
  <script>
    // Initialize CodeMirror on the textarea
    const editor = CodeMirror.fromTextArea(document.getElementById("code-input"), {
      lineNumbers: true,
      mode: "python",
      theme: "idea"  // You can change the theme if desired.
    });

    async function main() {
      // Load Pyodide and the simulation code.
      const pyodide = await loadPyodide();
      const response = await fetch('racer.py');
      const racerCode = await response.text();
      await pyodide.runPythonAsync(racerCode);
      const racer = pyodide.globals.get("racer");
      
      // Set up the main canvas.
      const canvas = document.getElementById("simCanvas");
      const ctx = canvas.getContext("2d");
      
      // Load the background map and car images.
      const backgroundMap = new Image();
      backgroundMap.src = "Robot_Racer_Path_new.svg";
      const carImage = new Image();
      carImage.src = "Robot_new.svg";
      
      // Create an offscreen canvas to hold a copy of the background.
      const offscreenBg = document.createElement('canvas');
      offscreenBg.width = canvas.width;
      offscreenBg.height = canvas.height;
      const offscreenBgCtx = offscreenBg.getContext("2d");
      backgroundMap.onload = () => {
        offscreenBgCtx.drawImage(backgroundMap, 0, 0, offscreenBg.width, offscreenBg.height);
      };
      
      let lastTime = performance.now();
      function animate(time) {
        const dt = (time - lastTime) / 1000;
        lastTime = time;
        
        // Advance simulation.
        racer.update(dt);
        
        // Retrieve simulation state.
        const x = Number(racer.x);
        const y = Number(racer.y);
        const angle = Number(racer.angle);
        const carWidth = Number(racer.racer_width);
        const carHeight = Number(racer.racer_height);
        const sensorWidth = Number(racer.sensor_width);
        const sensorHeight = Number(racer.sensor_height);
        
        // --- Collision Detection ---
        const bt = 10;  // border thickness
        const rw = carWidth / 2;
        const rh = carHeight / 2;
        const x1 = bt + rw;
        const x2 = canvas.width - bt - rw;
        const y1 = bt + rh;
        const y2 = canvas.height - bt - rh;
        if (x < x1 || x > x2 || y < y1 || y > y2) {
          racer.apply_power(0, 0);
        }
        
        // --- Compute Sensor Box World Coordinates ---
        // We want the sensor box to be flush with the car's front.
        // In car's local coordinates (angle=0 means car faces upward), the car's front edge is at y = -carHeight/2.
        // Place the sensor box so its bottom edge is flush with the car's front.
        // Thus, in car coordinates, the sensor box's top-left is at:
        //    (-sensorWidth/2, -carHeight/2 - sensorHeight)
        // The sensor box's center in car coordinates is:
        //    (0, -carHeight/2 - sensorHeight/2)
        // Convert that center to world coordinates:
        const sensorCenterWorldX = x + (0 * Math.cos(angle) - (-carHeight/2 - sensorHeight/2) * Math.sin(angle));
        const sensorCenterWorldY = y + (0 * Math.sin(angle) + (-carHeight/2 - sensorHeight/2) * Math.cos(angle));
        // Then the top-left in world coordinates is:
        const sensorBoxWorldX = sensorCenterWorldX - sensorWidth / 2;
        const sensorBoxWorldY = sensorCenterWorldY - sensorHeight / 2;
        
        // --- Draw the Scene ---
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (backgroundMap.complete) {
          ctx.drawImage(backgroundMap, 0, 0, canvas.width, canvas.height);
        }
        if (carImage.complete) {
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(angle);
          ctx.drawImage(carImage, -carWidth/2, -carHeight/2, carWidth, carHeight);
          ctx.restore();
        }
        
        // --- Draw Sensor Box (Flush with Car Front) ---
        // Draw in the car's local coordinate system.
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.strokeStyle = "purple";
        ctx.lineWidth = 2;
        ctx.strokeRect(-sensorWidth/2, -carHeight/2 - sensorHeight, sensorWidth, sensorHeight);
        ctx.restore();
        
        // --- Extract Sensor Image for Picture-in-Picture (PIP) ---
        // Use a temporary canvas to "unrotate" the sensor region.
        // Create a temporary canvas that matches the sensor box dimensions.
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = sensorWidth;
        tempCanvas.height = sensorHeight;
        const tempCtx = tempCanvas.getContext("2d");
        tempCtx.clearRect(0, 0, sensorWidth, sensorHeight);
        tempCtx.save();
        // Translate to the center of the temporary canvas.
        tempCtx.translate(sensorWidth/2, sensorHeight/2);
        // Rotate by -angle to undo the car's rotation.
        tempCtx.rotate(-angle);
        // Translate so that the sensor box's center aligns with the temp canvas center.
        tempCtx.translate(-sensorCenterWorldX, -sensorCenterWorldY);
        // Draw the offscreen background onto the temporary canvas.
        tempCtx.drawImage(offscreenBg, 0, 0, offscreenBg.width, offscreenBg.height);
        tempCtx.restore();
        
        // Now sample the sensor data.
        let sensorData;
        try {
          sensorData = tempCtx.getImageData(0, 0, sensorWidth, sensorHeight);
        } catch (e) {
          console.error("Error extracting sensor data:", e);
          sensorData = null;
        }
        let sum = 0, count = 0;
        if (sensorData) {
          const data = sensorData.data;
          for (let i = 0; i < data.length; i += 4) {
            sum += (data[i] + data[i+1] + data[i+2]) / 3;
            count++;
          }
        }
        const avgBrightness = count ? sum / count : 0;
        console.log("Sensor brightness:", avgBrightness);
        racer.sensor_val = avgBrightness;
        
        // --- Draw Sensor Picture-in-Picture (PIP) ---
        const scaleFactor = 5;
        const pipWidth = sensorWidth * scaleFactor;
        const pipHeight = sensorHeight * scaleFactor;
        const pipX = canvas.width - pipWidth - 10;
        const pipY = 10;
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        ctx.strokeRect(pipX, pipY, pipWidth, pipHeight);
        ctx.drawImage(tempCanvas, pipX, pipY, pipWidth, pipHeight);
        
        // --- Draw Sensor and Power Text ---
        ctx.font = "14px Arial";
        ctx.fillStyle = "black";
        ctx.fillText(`Sensor: ${avgBrightness.toFixed(2)}`, pipX, pipY + pipHeight + 20);
        ctx.fillText(`Power: ${Number(racer.power_consumed).toFixed(2)}`, pipX, pipY + pipHeight + 40);
        
        // --- Run User-Controlled Code, if defined ---
        if (pyodide.globals.get("racer_control")) {
          pyodide.runPython("racer_control()");
        }
        
        requestAnimationFrame(animate);
      }
      requestAnimationFrame(animate);
      
      // Hook up the "Run Code" button.
      document.getElementById("run-code").addEventListener("click", async () => {
        // Get code from the CodeMirror instance.
        const code = editor.getValue();
        try {
          await pyodide.runPythonAsync(code);
        } catch (err) {
          console.error("Python Error:", err);
          alert("Python Error:\n" + err);
        }
      });
    }
    main();
  </script>
</body>
</html>
